
<html>

<head>
  <link rel="stylesheet" type="text/css" href="../../css/default_dark.css">
  <link rel="stylesheet" type="text/css" href="../../css/syntax_dark.css">
</head>

<body>
  <center>
    <div style="display: inline-block; vertical-align:middle;">
      <a href="/" style="text-decoration: none;">SASON REZA<br>
      </a>
      <hr>
      <div style="text-align: center;display: inline-block; width: 100%;">
        <a class="title" href="../../about">ABOUT</a> &nbsp;<a class="title" href="../../contact">CONTACT</a>
      </div>
    </div>
  </center>

  <br>
  <p style="margin-bottom: 2ch;text-align: right;font-style: italic;">April 30, 2022</p>

<p><title>Deep Learning with Python: Chapter 2 - Mathematical building blocks of neural networks</title></p>

<h1 id="deep-learning-with-python">Deep Learning with Python</h1>

<p>This article is part 2/13 (?) of a series of articles named <em>Deep Learning with Python</em>.</p>

<p>In this series, I will read through the second edition of <em>Deep Learning with Python</em> by Fran√ßois Chollet.
Articles in this series will sequentially review key concepts, examples, and interesting facts from each chapter of the book.</p>

<hr />

<h1 id="chapter-2-the-mathematical-building-blocks-of-neural-networks">Chapter 2: The mathematical building blocks of neural networks</h1>

<p>This chapter covers...</p>

<ul>
<li>A first example of a neural network</li>
<li>Tensors and tensor operations</li>
<li>How neural networks learn via backpropagation and gradient descent</li>
</ul>

<p>Understanding deep learning requires familiarity with many simple mathematical concepts: <em>tensors</em>, <em>tensor operations</em>, <em>differentiation</em>, <em>gradient descent</em>, and so on.
This chapter will build on the concepts above without getting overly technical.
The use of precise, unambiguous executable code, instead of mathematical notation, will allow most programmers to easily grasp these concepts.</p>

<hr />

<h2 id="first-look-at-neural-networks">First look at neural networks</h2>

<p>Concrete example of a neural network (NN) with the use of the Python library <code>Keras</code> to learn how to classify handwritten digits.</p>

<h3 id="the-problem">The problem</h3>

<p>The problem we're trying to solve here is to classify grayscale images of handwritten digits (28x28 pixels) into their 10 categories (digits 0 through 9).
This problem is commonly referred to as the "Hello World" of deep learning - it's what you do to verify your algorithms are working as expected.</p>

<blockquote>
  <p><strong>NOTE</strong>: Classification problem keywords</p>
  
  <p>In ML classification problems, a <strong>category</strong> is called a <strong>class</strong>.
  Data points - such as individual train or test images - are called <strong>samples</strong>.
  The class associated with a specific sample is called a <strong>label</strong>.</p>
</blockquote>

<p>We'll be using the MNIST dataset: a set of 60,000 training images, plus 10,000 test images, assembled by the National Institute of Standards and Technology (the NIST in MNIST) in the 1980s.</p>

<p>The MNIST dataset is preloaded in <code>Keras</code>, in the form of four <code>NumPy</code> arrays</p>

<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">tensorflow.keras.datasets</span> <span class="kn">import</span> <span class="n">mnist</span>
<span class="p">(</span><span class="n">train_images</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">),</span> <span class="p">(</span><span class="n">test_images</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mnist</span><span class="o">.</span><span class="n">load_data</span><span class="p">()</span>
</code></pre></div>

<p>Let's take a peek at the shape of the data.
We should see 60,000 training images and labels, 10,000 test images and labels.</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">train_images</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">60000</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">train_labels</span><span class="p">)</span>
<span class="mi">60000</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">train_labels</span>
<span class="n">array</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">8</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">test_images</span><span class="o">.</span><span class="n">shape</span>
<span class="p">(</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_labels</span><span class="p">)</span>
<span class="mi">10000</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">test_labels</span>
<span class="n">array</span><span class="p">([</span><span class="mi">7</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">uint8</span><span class="p">)</span>
</code></pre></div>

<p>Let's look at a sample image using the <code>matplotlib</code> library:</p>

<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">digit</span> <span class="o">=</span> <span class="n">train_images</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imgshow</span><span class="p">(</span><span class="n">digit</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">plit</span><span class="o">.</span><span class="n">cm</span><span class="o">.</span><span class="n">binary</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<p><font style="color:red">TODO: Insert MNIST sample digits</font></p>

<p>Lastly, let's look at what label corresponds to the previous image:</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">train_labels</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
<span class="mi">9</span>
</code></pre></div>

<h3 id="defining-the-network-architecture">Defining the network architecture</h3>

<p>The core building block of a neural network is the <em>layer</em>.
A layer can be considered as a data filter: data goes in, and comes out more purified - more useful.
Specifically, layers extract <em>representations</em> out of the input data.</p>

<p>In deep learning models, simple layers are chains together to form a <em>data distillation</em> network.
Deep learning models could be visualized as a sieve for data processing - successive layers refining input data more and more.</p>

<p>The following example is a two-layer neural network.
We aren't expected to know exactly what the example means - we'll learn throughout the next two chapters.</p>

<p>The model consists of a sequence of two <code>Dense</code> layers, which are densely connected (also called <em>fully connected</em>).
The second layer is a 10-way <em>softmax classification</em> layer, which means it will return an array of 10 probability scores (summing to 1).
Each score will be the probability that the current digit image belongs to on our of 10 digit classes.</p>

<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras</span> <span class="kn">import</span> <span class="n">layers</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;relu&quot;</span><span class="p">),</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;softmax&quot;</span><span class="p">)</span>
<span class="p">])</span>
</code></pre></div>

<h3 id="preparing-the-model-for-training">Preparing the model for training</h3>

<p>Before we begin training, we must compile three more things, in addition to the training and testing data, as part of the <em>compilation</em> step:
We brushed over the jobs of the loss score and optimizer in the previous chapter.
The specifics of their jobs will be made clear throughout the next two chapters.</p>

<ol>
<li><em>An optimizer</em>: How the model will update itself - its weights - based on the training data it sees, so as a to improve its performance</li>
<li><em>A loss function</em>: How the model will measure its performance on the training data and how it will be able to steer itself in the more correct direction</li>
<li><em>Metrics to monitor during training and testing</em>: For now, we'll only care about accuracy - the fraction of images that were correctly classified</li>
</ol>

<div class="codehilite"><pre><span></span><code><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s2">&quot;rmsprop&quot;</span><span class="p">,</span>
              <span class="n">loss</span><span class="o">=</span><span class="s2">&quot;sparse_categorical_crossentropy&quot;</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;accuracy&quot;</span><span class="p">])</span>
</code></pre></div>

<h3 id="preparing-the-data">Preparing the data</h3>

<p>Before training, we'll preprocess the data to ensure consistent data shapes and scales.
We'll reshape the data into the shape the model expects and scale it so that all values are in the [0, 1] interval instead of [0, 255] interval.</p>

<p>The training image data will be transformed from a <code>uint8</code> array of shape <code>(60000, 28, 28)</code> with values between [0, 255] to a <code>float32</code> array of shape <code>(60000, 28*28)</code> with values between [0, 1].
The same will be done to the testing image data.</p>

<div class="codehilite"><pre><span></span><code><span class="n">train_images</span> <span class="o">=</span> <span class="n">train_images</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">60000</span><span class="p">,</span> <span class="mi">28</span><span class="o">*</span><span class="mi">28</span><span class="p">))</span>
<span class="n">train_images</span> <span class="o">=</span> <span class="n">train_images</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
<span class="n">test_images</span> <span class="o">=</span> <span class="n">test_images</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">28</span><span class="o">*</span><span class="mi">28</span><span class="p">))</span>
<span class="n">test_images</span> <span class="o">=</span> <span class="n">test_images</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
</code></pre></div>

<h3 id="fitting-training-the-model">"Fitting" (Training) the model</h3>

<p>With the data properly pre-processed, we are finally read to train the model!
In Keras, training the model is done via a call to the model's <code>fit()</code> method - we <em>fit</em> the model to its training data.</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_images</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
<span class="n">Epoch</span> <span class="mi">1</span><span class="o">/</span><span class="mi">5</span>
<span class="mi">60000</span><span class="o">/</span><span class="mi">60000</span> <span class="p">[</span><span class="o">==========================</span><span class="p">]</span> <span class="o">-</span> <span class="mi">5</span><span class="n">s</span> <span class="o">-</span> <span class="n">loss</span><span class="p">:</span> <span class="mf">0.2524</span> <span class="o">-</span> <span class="n">acc</span><span class="p">:</span> <span class="mf">0.9273</span>
<span class="n">Epoch</span> <span class="mi">2</span><span class="o">/</span><span class="mi">5</span>
<span class="mi">51328</span><span class="o">/</span><span class="mi">60000</span> <span class="p">[</span><span class="o">====================&gt;.....</span><span class="p">]</span> <span class="o">-</span> <span class="n">ETA</span><span class="p">:</span> <span class="mi">1</span><span class="n">s</span> <span class="o">-</span> <span class="n">loss</span><span class="p">:</span> <span class="mf">0.1035</span> <span class="o">-</span> <span class="n">acc</span><span class="p">:</span> <span class="mf">0.9692</span>
</code></pre></div>

<p>The model swiftly reaches a decent accuracy of 96% after roughly 2 epochs of fitting to the training data.</p>

<h3 id="making-predictions-with-the-trained-model">Making predictions with the trained model</h3>

<p>Now that the model is trained, we can use it to make class predictions on the <em>new</em>, unseen data - such as the testing images.</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">test_digit</span> <span class="o">=</span> <span class="n">test_images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">prediction</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_digit</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">prediction</span>
<span class="n">array</span><span class="p">([</span><span class="mf">1.0726176e-10</span><span class="p">,</span> <span class="mf">1.6918376e-10</span><span class="p">,</span> <span class="mf">6.1314843e-08</span><span class="p">,</span> <span class="mf">8.4106023e-06</span><span class="p">,</span>
       <span class="mf">2.9967067e-11</span><span class="p">,</span> <span class="mf">3.0331331e-09</span><span class="p">,</span> <span class="mf">8.3651971e-14</span><span class="p">,</span> <span class="mf">9.9999106e-01</span><span class="p">,</span>
       <span class="mf">2.6657624e-08</span><span class="p">,</span> <span class="mf">3.8127661e-07</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float32</span><span class="p">)</span>
</code></pre></div>

<p>Each index <em>i</em> in <code>predictions[0]</code> corresponds to the probability that <code>prediction</code> belongs to class <em>i</em>.
In this example, the highest probability is index 7, meaning the model believes that <code>test_digit</code> is the number 7.</p>

<p>We can verify if the model's prediction is correct by comparing the prediction against the test_labels data.</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">predictions</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>  <span class="c1"># Return the index of the highest probability</span>
<span class="mi">7</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">predictions</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
<span class="mf">0.99999106</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">test_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">7</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">predictions</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span> <span class="o">==</span> <span class="n">test_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="kc">True</span>
</code></pre></div>

<h3 id="evaluating-the-model-on-new-data">Evaluating the model on new data</h3>

<p>We can evaluate the model's accuracy against data it has never seen before using the model's <code>evaluate()</code> method.
This method will allow us to compute the average accuracy against an entire test set.</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">test_loss</span><span class="p">,</span> <span class="n">test_acc</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">test_images</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;test_acc: </span><span class="si">{</span><span class="n">test_acc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">test_acc</span><span class="p">:</span> <span class="mf">0.9785</span>
</code></pre></div>

<p>This concludes our first example.
We just saw how easy it is to build and train a neural network classification model in less than 15 lines of Python code.</p>

<p>Let's learn more about data representations and how the neural network interprets and refines input data using tensors.</p>

<hr />

<h2 id="data-representations-tensors">Data representations: Tensors</h2>

<p><em>Tensors</em> are fundamental data structures used in machine learning.
At its core, a tensor is a container for data - usually numeric data.
Matrices (2D arrays) are considered to be rank-2 tensors.</p>

<p>Therefore, tensors are generalizations of matrices to an arbitrary number of <em>dimensions</em>.
Note that in the context of tensors, a dimension is often called an <em>axis</em>.</p>

<p>Let's take a look at definitions and examples of rank-0 to rank-3 and higher tensors.</p>

<h3 id="scalars-rank-0-tensors">Scalars (rank-0 tensors)</h3>

<p>A tensor that contains only one number is called a <em>scalar</em> - or scalar tensor, rank-0 tensor, or 0D tensor.
Using NumPy's <code>ndim</code> attribute, you'll notice a scalar tensor has 0 <em>axes</em> (<code>ndim == 0</code>).
The number of axes of a tensor is also called its <em>rank</em>.</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">22</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
<span class="mi">0</span>
</code></pre></div>

<h3 id="vectors-rank-1-tensors">Vectors (rank-1 tensors)</h3>

<p>An array of numbers is called a <em>vector</em> - or rank-1 tensor, 1D tensor, tensor of rank 1.
A rank-1 tensor has exactly one axis.</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">93</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span>
<span class="n">array</span><span class="p">([</span><span class="mi">15</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">93</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
<span class="mi">1</span>
</code></pre></div>

<p>The vector above has five entries and so is called a <em>5-dimensional vector</em>.
It's important to not confuse a 5D <em>vector</em> with a 5D <em>tensor</em>.
A 5D vector has a single axis and has five dimensions along its axis.
A 5D tensor - or <em>tensor of rank 5</em> -  on the other hand, has five axes and any number of dimensions along each axes.</p>

<h3 id="matrices-rank-2-tensors">Matrices (rank-2 tensors)</h3>

<p>An array of vectors is a <em>matrix</em> - or rank-2 tensor, 2D tensor, tensor of rank 2.
A matrix has two axes often referred to as <em>rows</em> and <em>columns</em>.</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">24</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>
                  <span class="p">[</span><span class="mi">44</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="mi">62</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
<span class="mi">2</span>
</code></pre></div>

<p>The entries from the first axis are called the <em>rows</em>, and the entries from the second axis are called the <em>columns</em>.
<code>[4, 8, 15, 16, 23, 42]</code> is the first row of <code>x</code>, and <code>[4, 24, 44]</code> is the first column.</p>

<h3 id="rank-3-and-higher-rank-tensors">Rank-3 and higher-rank tensors</h3>

<p>If you insert matrices (rank-2 tensors) into an array, you obtain a rank-3 tensor.
Rank-3 tensors can be visualized as a cube of numbers.</p>

<div class="codehilite"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">22</span><span class="p">],</span>
                   <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">23</span><span class="p">],</span>
                   <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">]],</span>
                  <span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
                   <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">61</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">23</span><span class="p">],</span>
                   <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">52</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">29</span><span class="p">]]])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
<span class="mi">3</span>
</code></pre></div>

<p>Inserting rank-3 tensors in an array will create a rank-4 tensor, and so on.
In deep learning, we'll generally only work with rank-0 to rank-4 tensors.
Although, rank-5 tensors may be used if processing video data.</p>

<h3 id="key-attributes">Key attributes</h3>

<ul>
<li><em>Number of axes (rank)</em>: For instance, a rank-3 tensor has three axes, and a matrix has two axes. This is also called the tensor's <code>ndim</code> in Python libraries such as NumPy or TensorFlow.</li>
<li><em>Shape</em>: This is a tuple of integers that describes how many dimensions the tensor has along each axis.
For instance, a matrix with shape <code>(3, 5)</code> has three rows and five columns.
A vector with a single element could have the shape <code>(5,)</code>, whereas a scalar has an empty shape, <code>()</code>.
Lastly, a rank-3 tensor, such as the example above, has shape <code>(2, 3, 5)</code>.</li>
<li><em>Data type</em>: Usually called the<code>dtype</code> in Python libraries, this is the type of the data contained in the tensor.
For instance, a tensor's type could be <code>float16</code>, <code>float32</code>, <code>uint8</code>, and so on.
It's also possible to come across <code>string</code> tensors in TensorFlow.</li>
</ul>

<hr />

<h2 id="real-world-examples-of-data-tensors">Real-world examples of data tensors</h2>

<ul>
<li><em>Vector data</em>: Rank-2 tensors of shape <code>(samples, features)</code>, where each sample is a vector of numerical attributes ("features")</li>
<li><em>Timeseries data or sequence data</em>: Rank-3 tensors of shape <code>(samples, timesteps, features)</code>, where each sample is a sequence (of length <code>timesteps</code>) of feature vectors</li>
<li><em>Images</em>: Rank-4 tensors of shape <code>(samples, height, width, channels)</code>, where each sample is a 2D grid of pixels, and each pixel is represented by a vector of values ("channels").</li>
<li><em>Video</em>: Rank-5 tensors of shape <code>(samples, frames, height, width, channels)</code>, where each sample is a sequence (of length <code>frames</code>) of images</li>
</ul>

<h3 id="vector">Vector</h3>

<p>This is one of the most common use cases of tensors.
Each data point in a dataset is encoded as a vector.
A batch of data will be encoded as a rank-2 tensor - that is, an array of vectors - where the first axis is the <code>samples axis</code> and the second axis is he <code>features axis</code>.</p>

<p>Let's look at an example:</p>

<ul>
<li>A dataset of cars, where we consider each car's make, model, manufactured year, and odometer reading.
Each car can be characterized as a vector of 4 values.
An entire dataset of 100,000 cars can be stored in a rank-2 tensor of shape <code>(100000, 4)</code>.</li>
</ul>

<h3 id="timeseries-data-or-sequence-data">Timeseries data or sequence data</h3>

<p>Whenever time matters in your data - or the notion of sequential order - it makes sense to store it in a rank-3 tensor with an explicit time axis.
Each sample can be encoded as a sequence of vectors (a rank-2 tensor), and thus a batch of data will be encoded as a rank-3 tensor.</p>

<p><font style="color:red">TODO: Insert rank-3 timeseries data tensor</font></p>

<p>By convention, the time axis is always the second axis.
Let's take a look at an example:</p>

<ul>
<li><p>A dataset of a MotoGP rider's lap around Laguna Seca.
Every percentage of lap completed, we store the motorcycle's speed, lean angle, throttle input, brake input, and steering input.
Ideally, it would be as close to realtime as possible instead of every single percentage, but let's keep it simple.
Thus, every lap is encoded as a 5D vector of shape <code>(101, 5)</code>, where 101 is 0 percent to 100 percent, inclusive.
An entire race (assuming 30 laps) is encoded as a rank-3 tensor of shape <code>(30, 101, 5)</code>.</p></li>
<li><p>A dataset of stock prices.
Every minute, we store the current price of the stock, the highest price in the past minute, and the lowest price in the past minute.
Thus, every minute is encoded as a 3D vector, an entire day of trading is encoded as a matrix of shape <code>(390, 3)</code> (there are 390 minutes in a trading day), and 365 days' worth of data can be stored in a rank-3 tensor of shape <code>(365, 390, 3)</code>.
Here, each sample would be one day's worth of data.</p></li>
</ul>

<h3 id="image-data">Image data</h3>

<p>Images usually have three dimensions: height, width, and color channels.
Grayscale images (black-and-white images, like our MNIST images) have only a single color channel.
Colored images typically have three color channels: RGB (red, green, blue).</p>

<p>A batch of 500 grayscale images of size 256x256 could thus be stored in a rank-4 tensor of shape <code>(500, 256, 256, 1)</code>, whereas a batch of 500 <em>colored</em> images could be stored in a tensor a shape <code>(500, 256, 256, 3)</code>.</p>

<p><font style="color:red">TODO: Insert rank-4 image data tensor</font></p>

<h3 id="video-data">Video data</h3>

<p>Video data is one of the few types of real-world data for which rank-5 tensors are used.
A video can be simplified as a sequence of frames, each frame being a color image.</p>

<p>Each frame can be stores in a rank-3 tensor <code>(height, width, color_channel)</code>.
A sequence of frames can be stored in a rank-4 tensor <code>(frames, height, width, color_channel)</code>.
Therefore, a batch of videos can be stored in a rank-5 tensor of shape <code>(samples, frames, height, width, color_channel)</code>.</p>

<p>For instance, a 20-second, 1920x1080 video clip sampled at 10 frames per second would have 200 frames.
A batch of 5 such video clips would be stored in a tensor of shape <code>(5, 200, 1920, 1080, 3)</code>.
That's a total of 6,220,800,000 values!</p>

<hr />

<h2 id="tensor-operations">Tensor operations</h2>

<hr />

<h2 id="how-neural-networks-learn-via-backpropagation-and-gradient-descent">How neural networks learn via backpropagation and gradient descent</h2>

<h3 id="backpropagation-algorithm">Backpropagation algorithm</h3>

<p>How can we get the gradient of the loss with respect to the weights?
Using the <em>Backpropagation algorithm</em>.</p>

<hr />

<h2 id="recap-looking-back-at-our-first-example">Recap: Looking back at our first example</h2>

<p>We should now have a general understanding of what's going on behind the scenes in a neural network.
What was previously a mysterious black box has turned into a clearer picture seen below: the <strong>model</strong>, composed of sequential <strong>layers</strong>, maps the input data to predictions.
The loss function then compares the predictions to the target values, producing a <strong>loss value</strong>: a measure of how well the model's predictions match what was expected.
The <strong>optimizer</strong> uses this loss value to update the model's <strong>weights</strong>.</p>

<h3 id="input">Input</h3>

<p>Now we understand that the input images are stored in NumPy tensors.
Prior to training the model, the input images - training and testing images - were pre-processed: training tensors were converted to type <code>float32</code> and reshaped to shape <code>(60000, 28*28)</code> from <code>(60000, 28, 28)</code>, and testing tensors were similarly reformatted and reshaped <code>(10000, 28*28)</code> from <code>(10000, 28, 28)</code>.</p>

<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">train_images</span><span class="p">,</span> <span class="n">train_labels</span><span class="p">),</span> <span class="p">(</span><span class="n">test_images</span><span class="p">,</span> <span class="n">test_labels</span><span class="p">)</span> <span class="o">=</span> <span class="n">mnist</span><span class="o">.</span><span class="n">load_data</span><span class="p">()</span>
<span class="n">train_images</span> <span class="o">=</span> <span class="n">train_images</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">60000</span><span class="p">,</span> <span class="mi">28</span> <span class="o">*</span> <span class="mi">28</span><span class="p">))</span>
<span class="n">train_images</span> <span class="o">=</span> <span class="n">train_images</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
<span class="n">test_images</span> <span class="o">=</span> <span class="n">test_images</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">10000</span><span class="p">,</span> <span class="mi">28</span> <span class="o">*</span> <span class="mi">28</span><span class="p">))</span>
<span class="n">test_images</span> <span class="o">=</span> <span class="n">test_images</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;float32&quot;</span><span class="p">)</span> <span class="o">/</span> <span class="mi">255</span>
</code></pre></div>

<h3 id="layers">Layers</h3>

<p>Recall that our two-layer neural network model was created like so:</p>

<div class="codehilite"><pre><span></span><code><span class="kn">from</span> <span class="nn">tensorflow</span> <span class="kn">import</span> <span class="n">keras</span>
<span class="kn">from</span> <span class="nn">tensorflow.keras</span> <span class="kn">import</span> <span class="n">layers</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">keras</span><span class="o">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;relu&quot;</span><span class="p">),</span>
    <span class="n">layers</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s2">&quot;softmax&quot;</span><span class="p">)</span>
<span class="p">])</span>
</code></pre></div>

<p>We now understand that this model consists of a chain of two <code>Dense</code> layers.
Each layer performs simple tensor operations to the input data, further refining the data to more useful data representations.</p>

<p>These layers are incorporate the usage of layer <em>weight</em> tensors.
Weight tensors, which are attributes of the layers, are where the <em>knowledge</em> of the model persists.</p>

<h3 id="loss-function-and-optimizer">Loss function and optimizer</h3>

<p>This was the model-compilation step:</p>

<div class="codehilite"><pre><span></span><code><span class="n">model</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s2">&quot;rmsprop&quot;</span><span class="p">,</span>
              <span class="n">loss</span><span class="o">=</span><span class="s2">&quot;sparse_categorical_crossentropy&quot;</span><span class="p">,</span>
              <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;accuracy&quot;</span><span class="p">])</span>
</code></pre></div>

<p>We understand that <code>sparse_categorical_crossentropy</code> is the loss function that's used as to calculate the loss score.
The loss score is used as a feedback signal for learning the weight tensors.
During the training phase, the training loop will attempt to minimize the loss score.</p>

<p>The reduction of the loss happens via mini-batch stochastic (random) gradient descent.
The exact rules and specifications of loss reduction are defined by the <code>rmsprop</code> optimizer passed as the model's first argument.</p>

<h3 id="training-loop">Training loop</h3>

</body>
</html>
